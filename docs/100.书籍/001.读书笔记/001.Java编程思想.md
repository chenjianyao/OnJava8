# 读书笔记

<!-- Interfaces -->
## 第十章 接口

多接口结合

```
一个类继承基类并实现多个接口时，需要将继承具体类放在前面，实现接口放在后面。否则编译器会报错。

class Hero extends ActionCharacter implements CanFight, CanSwim, CanFly {}
```

使用继承扩展接口

```
通过继承，可以扩展一个或者多个接口。 extends这种用法只适用于接口继承

interface Vampire extends DangerousMonster, Lethal {}
```

结合接口时注意命名冲突

```
覆写、实现、重载搅在一起带来困难。重载方法仅根据返回类型是区分不了的。
当打算结合接口时，在不同的接口中使用相同的方法名通常会造成代码可读性的混乱，尽量避免这种情况。
```

接口适配

```
接口最吸引人的原因之一是相同的接口可以有多个实现。接口的一种常见用法是策略设计模式。编写一个方法执行某些操作并接受一个指定的接口作为参数。只要对象实现接口，就可以调用该方法。这使得方法更加灵活，通用，并更具可复用性。

Scanner的构造器接受一个Readable接口。通过这种方式，Scanner可以与更多的类型协作。如果你创建一个新类并想让Scanner调用它，就让它实现Readable接口。如果一个类没有实现Readable接口，怎么才能让Scanner调用它呢？使用适配器模式，新类实现Readable接口
```

接口字段

```
接口中字段都自动是static和final的。所以在java5之前，接口成为了创建一组常量的方便工具（Java5之后使用enum）

public interface Months { int JANUARY = 1;}
```

初始化接口中的字段

```
接口中的定义的字段不能是空final，可以用非常量表达式初始化。例如:

public interface RandVals { Random RAND = new Random(47); int RANDOM_INT = RAND.nextInt()10;}

这些字段不是接口的一部分，值被存储在接口的静态存储区域中。
```

<!-- Inner Classes -->
# 第十一章 内部类

创建内部类

```
定义在另一个类中的类，叫做内部类。把类的定义置于外部类的里面，外部类定义个方法，该方法返回一个指向内部类的引用。
```

链接外部类

```
内部类可以访问其外部类的方法和字段，内部类自动拥有对其外部类所有成员的访问权。
```

使用.this和.new

```
内部类中生成对外部类对象的引用，可以使用 外部类.this，编译期被检查，没有运行时开销

外部类创建内部类的对象，使用 外部类.new 内部类();

DotNew.Inner dni = dotNew.new Inner();
```

匿名内部类

```
创建一个集成自Contents的匿名类的对象。通过new表达式返回的引用被自动向上转型为对Contents的引用。

如果在定义一个匿名内部类，它要使用一个外部环境（在本匿名内部类之外定义）对象，那么编译器会要求其参数引用是final的。

匿名内部类中可以定义字段，定义实例初始化 {}方法

匿名内部类与普通的继承相比有些受限，因为匿名内部类要么继承类，要么实现接口，不能两者兼备。如果是实现接口，也只能实现一个接口。
```

嵌套类

```
不需要内部类对象与其外部类对象之间有联系，那么可以将内部类声明为static，这通常称为嵌套类。

创建嵌套类对象时，不需要其外部类的对象。

不能从嵌套类的对象中访问非静态的外部类对象。

普通的内部类不能有static数据和static字段，也不能包含嵌套类。普通的内部类中，通过一个特殊的this引用可以连接到其外部类对象。嵌套类就没有这个特殊的this引用，这使得它类似于一个static方法。
```

接口内部的类

```
放在接口中的任何类自动地是Public和static的。因为类是static的，只能将嵌套类置于接口的命名空间内.
```

<!-- Collections -->
# 第十二章 集合

泛型和类型安全的集合

```
使用泛型，可以在编译期防止将错误类型的对象防止到集合中。使用泛型，从List中获取元素不需要强制类型转换。因为List知道它持有什么类型，因此当调用get()时，它会替你执行转型。当指定了某个类型为泛型参数时，并不仅限于只能将确切类型的对象放入集合中。向上转型也可以像作用于其他类型一样作用于泛型。

```

添加元素组

```
Arrays.asList()方法接受一个数组或逗号分隔的元素列表（使用可变参数），并将其转换为List对象。但是这个底层是数组，没法调整大小。如果尝试在这个List上调用add()或remove(),由于这两个方法会尝试修改数组大小，所以会在运行时得到"Unsupported Operation"

显示类型参数说明

List<Snow> snow4 = Arrays.<Snow>asList(new Light(), new Heavy());
```

集合的打印

```
subList()所产生的列表实际就是原始列表。因为，对返回列表的更改都将会反映在原始列表中。反之亦然。
```

优先级队列PriorityQueue

```
优先级队列：下一个弹出的元素具有最高的优先级。当在PriorityQueue上调用offer()方法插入一个对象时，对象会在队列中被排序。默认的排序使用队列中对象的自然顺序，可以通过提供自己的Comparator来修改排序规则。
```

























