# 读书笔记

<!-- Interfaces -->
## 第十章 接口

多接口结合

```
一个类继承基类并实现多个接口时，需要将继承具体类放在前面，实现接口放在后面。否则编译器会报错。

class Hero extends ActionCharacter implements CanFight, CanSwim, CanFly {}
```

使用继承扩展接口

```
通过继承，可以扩展一个或者多个接口。 extends这种用法只适用于接口继承

interface Vampire extends DangerousMonster, Lethal {}
```

结合接口时注意命名冲突

```
覆写、实现、重载搅在一起带来困难。重载方法仅根据返回类型是区分不了的。
当打算结合接口时，在不同的接口中使用相同的方法名通常会造成代码可读性的混乱，尽量避免这种情况。
```

接口适配

```
接口最吸引人的原因之一是相同的接口可以有多个实现。接口的一种常见用法是策略设计模式。编写一个方法执行某些操作并接受一个指定的接口作为参数。只要对象实现接口，就可以调用该方法。这使得方法更加灵活，通用，并更具可复用性。

Scanner的构造器接受一个Readable接口。通过这种方式，Scanner可以与更多的类型协作。如果你创建一个新类并想让Scanner调用它，就让它实现Readable接口。如果一个类没有实现Readable接口，怎么才能让Scanner调用它呢？使用适配器模式，新类实现Readable接口
```

接口字段

```
接口中字段都自动是static和final的。所以在java5之前，接口成为了创建一组常量的方便工具（Java5之后使用enum）

public interface Months { int JANUARY = 1;}
```

初始化接口中的字段

```
接口中的定义的字段不能是空final，可以用非常量表达式初始化。例如:

public interface RandVals { Random RAND = new Random(47); int RANDOM_INT = RAND.nextInt()10;}

这些字段不是接口的一部分，值被存储在接口的静态存储区域中。
```

<!-- Inner Classes -->
## 第十一章 内部类

创建内部类

```
定义在另一个类中的类，叫做内部类。把类的定义置于外部类的里面，外部类定义个方法，该方法返回一个指向内部类的引用。
```

链接外部类

```
内部类可以访问其外部类的方法和字段，内部类自动拥有对其外部类所有成员的访问权。
```

使用.this和.new

```
内部类中生成对外部类对象的引用，可以使用 外部类.this，编译期被检查，没有运行时开销

外部类创建内部类的对象，使用 外部类.new 内部类();

DotNew.Inner dni = dotNew.new Inner();
```

匿名内部类

```
创建一个集成自Contents的匿名类的对象。通过new表达式返回的引用被自动向上转型为对Contents的引用。

如果在定义一个匿名内部类，它要使用一个外部环境（在本匿名内部类之外定义）对象，那么编译器会要求其参数引用是final的。

匿名内部类中可以定义字段，定义实例初始化 {}方法

匿名内部类与普通的继承相比有些受限，因为匿名内部类要么继承类，要么实现接口，不能两者兼备。如果是实现接口，也只能实现一个接口。
```

嵌套类

```
不需要内部类对象与其外部类对象之间有联系，那么可以将内部类声明为static，这通常称为嵌套类。

创建嵌套类对象时，不需要其外部类的对象。

不能从嵌套类的对象中访问非静态的外部类对象。

普通的内部类不能有static数据和static字段，也不能包含嵌套类。普通的内部类中，通过一个特殊的this引用可以连接到其外部类对象。嵌套类就没有这个特殊的this引用，这使得它类似于一个static方法。
```

接口内部的类

```
放在接口中的任何类自动地是Public和static的。因为类是static的，只能将嵌套类置于接口的命名空间内.
```

<!-- Collections -->
## 第十二章 集合

泛型和类型安全的集合

```
使用泛型，可以在编译期防止将错误类型的对象防止到集合中。使用泛型，从List中获取元素不需要强制类型转换。因为List知道它持有什么类型，因此当调用get()时，它会替你执行转型。当指定了某个类型为泛型参数时，并不仅限于只能将确切类型的对象放入集合中。向上转型也可以像作用于其他类型一样作用于泛型。

```

添加元素组

```
Arrays.asList()方法接受一个数组或逗号分隔的元素列表（使用可变参数），并将其转换为List对象。但是这个底层是数组，没法调整大小。如果尝试在这个List上调用add()或remove(),由于这两个方法会尝试修改数组大小，所以会在运行时得到"Unsupported Operation"

显示类型参数说明

List<Snow> snow4 = Arrays.<Snow>asList(new Light(), new Heavy());
```

集合的打印

```
subList()所产生的列表实际就是原始列表。因为，对返回列表的更改都将会反映在原始列表中。反之亦然。
```

优先级队列PriorityQueue

```
优先级队列：下一个弹出的元素具有最高的优先级。当在PriorityQueue上调用offer()方法插入一个对象时，对象会在队列中被排序。默认的排序使用队列中对象的自然顺序，可以通过提供自己的Comparator来修改排序规则。
```

<!-- Functional Programming -->
## 第十三章 函数式编程

通过合并现有代码来生成新功能而不是从头开始编写所有的内容，我们可以更快地获得更可靠的代码。
Java8的Lambda表达式，其参数和函数体被箭头->分隔开。箭头右侧是从Lambda返回的表达式。它与单独定义类和采用匿名内部类是等价的。
Java8的方法引用，它以::为特征。::的左边是类或对象的名称，右边是方法的名称，但是没有参数列表
Lambda表达式通常比匿名内部类更易读，因此优先使用Lambda表达式

新旧对比

```
传递给方法的数据不同，接口不同。如果希望方法在调用时行为不同？只要能将代码传递给方法，我们就可以控制行为。以前我们通过在方法中创建包含行为的对象，然后将该对象传递给方法来完成此操作。

Java8之前，我们能通过单独定义类或者采用匿名内部类的方式传递行为对象。Java8之后，可以使用方法引用和Lambda表达式传递
```

递归

```
递归函数是一个自我调用的函数。可以编写递归的Lambda表达式，注意：递归方法必须是实例变量或静态变量，否则会编译错误。
```

未绑定的方法引用

```
未绑定的方法引用是指没有关联对象的普通（非静态）方法。
使用未绑定的引用时，函数式方法的签名（接口中的单个方法）不再与方法引用的签名完全匹配。原因：你需要一个对象来调用方法。
```

构造函数引用

```
Dog有三个构造函数，每一个都使用Dog::new。赋值给不同的接口，编译器可以从中知道具体使用哪个构造函数。
```

函数式接口

```
Java8引用了java.util.funciton包。它包含一组接口，这些接口是Lambda表达式和方法引用的目标类型。每个接口只包含一个抽象方法，成为函数式方法。
@FunctionalInterface注解是可选的;Java8允许我们将函数赋值给接口。如果将方法引用或者Lambda
```

高阶函数

```
使用继承，可以轻松地为专用接口创建别名

interface FuncSS extends Function<Stirng, String> {}

使用Lambda表达式，可以轻松地在方法中创建和返回一个函数。

static FuncSS produce() { return s -> s.toLowerCase(); }
```

闭包

```
Java8提供了优先
```

<!-- Streams -->
## 第十四章 流式编程

流是与任何特定存储机制无关的元素序列-实际上，我们说流是没有存储的。
取代了在集合中迭代元素的做法，使用流即可从管道中提取元素并对其操作。

流创建

```
Stream().of()将一组元素转化为流

每个集合可以通过调用stream()方法来产生一个流
```

随机数流

```
Random类被一组生成流的方法增强了。

new Random().ints(5,20).distinct().limit(12).sorted().forEach(System.out::println);
```

int类型的范围

```
IntStream类提供了range()方法用于生成整形序列的流 IntSteam.range(1, 20)
```

中间操作

中间操作用于从一个流中获取对象，并将对象作为另一个流从后端输出，以连接到其他操作。

跟踪和调试

```
peek()操作的目的是帮助调试，允许无修改地查看流中的元素
```

流元素排序

```
.sorted(Comparator.reverseOrder()) 反转自然排序
```

<!-- File -->
## 第十七章 文件

文件和目录路径

```
path对象表示一个文件或者目录的路径，是一个跨操作系统和文件系统的抽象，目的是在构造路径时不必关注底层操作系统，代码可以在不进行修改的情况下运行在不同的操作系统上。
```

<!-- Strings -->
## 第十八章 字符串

+的重载与StirngBuilder

```
编译器会将+优化为StringBuilder对象

new Random(47).ints(25, 0, 100).mapToObj(Integer::toString).collect(Collectors.joining(", ")); Cpllectors.joining()内部也是使用的StringBuilder,这种写法不会影响性能。
```

意外递归

```
集合类覆盖了toString()方法，遍历集合中的所有对象，调用每个对象上的toStirng()方法

如果需要打印内存，不要直接在覆盖toStirng()方法返回this，这会发生自动类型转换，this转换成String,于是发生了递归调用。应该调用super.toString()方法。
```

字符串操作

```
列举了String对象具备的一些基本方法。
```

格式化输出

```
String.format("(t%d, q%d) %s", transactionID, queryID, message)
```

## 类型信息

类字面常量

```
boolean.class  =  Boolean.TYPE , 推荐使用.class形式，保持与普通类的一致性。

当使用.class来创建对Class对象的引用时，不会自动地初始化该Class对象。而使用Class.forName()来产生Class引用会立即进行初始化。static final值是编译器常量，那个这个值不需要类初始化就可以被读取。

如果一个static字段不是final的，那么访问这个字段时，要先进行链接（为这个字段分配存储空间）和初始化（初始化该存储空间）
```

泛化的Class引用

```
Java引入泛型语法之后，我们可以使用泛型对class引用所指向的Class对象的类型进行限定。通过使用泛型语法，我们可以让编译器强制执行额外的类型检查。

使用Class<?>比单纯使用Class要好，单纯使用Class不会产生编译器警告信息。使用Class<?>的好处是它表示你并非是碰巧或者由于疏忽才使用了一个非具体的类引用，而是特意为之。

创建一个限定指向某种类型或其子类的Class引用，我们需要经通配符与extends关键字配合使用，创建一个范围限定。
Class<? extends Number> bounded = int.class;
向Class引用添加泛型语法的原因只是为了提供编译器类型检查，使用普通的Class引用你要确保自己不会犯错，一旦犯了错误，就要等到运行时才能发现它，很不方便。

泛型语法用于Class对象时，newInstance()将返回该对象的确切类型。
```

























































































































































